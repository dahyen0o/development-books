## 키-값 저장소 (key-value store)

`키-값 데이터베이스` 라고도 불리며, 비 관계형 (non-relational) 데이터베이스이다. 

- 값은 고유 식별자(identifier)를 키로 가진다.
- 키는 유일해야 하며 해당 키에 매달린 값은 키를 통해서만 접근할 수 있다.
- 키가 짧을수록 성능이 좋다.

<br>

### 단일 서버 키-값 저장소

키-값 쌍 전부를 메모리에 해시 테이블로 저장하는 방법이다.

#### 장점

빠른 속도

#### 단점

많은 데이터를 저장하는 것이 불가능
- `데이터 압축(compression)` 또는 자주 쓰이지 않는 데이터를 디스크에 저장하는 방식으로 개선할 수 있다. 
- 하지만 개선해도 한계가 있다.

<br>

### 분산 키-값 저장소

키-값 쌍을 여러 서버에 분산시키는 방법이다.

> [!Note]
> **CAP 정리**
>
> `Consistency(데이터 일관성)`, `Availability(가용성)`, `Partition tolerance(파티션 감내)` 라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리다.
>
> - consistency: 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.
> - availability: 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
> - partition tolerance: 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.

<br>

### 데이터 파티션

데이터를 작은 파티션들로 분할한 다음 여러 서버에 저장하는 방법이다.

#### 고려할 점

1. 데이터를 여러 서버에 고르게 분산할 수 있는가
2. 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가

→ `안정 해시(consistent hash)` 를 통해 해결할 수 있다. (5장 참고)

<br>

### 데이터 다중화

데이터를 여러 서버에 `복사(replication)` 하는 방법이다. <br>
높은 가용성과 안정성을 확보하기 위해서는 데이터를 여러 서버에 비동기적으로 다중화할 필요가 있다.

#### 방법

하나의 데이터를 복사할 N개의 서버는 어떤 키를 해시 링 위에 배치한 후, 그 지점으로부터 시계 방향으로 순회하면서 만나는 첫 N개로 선택한다.

<br>

### 데이터 일관성

여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다. <br>
이 때 `정족수 합의(Quorum Consensus) 프로토콜` 을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.

#### 정족수 합의 프로토콜

```
- N = 사본 개수
- W = 쓰기 연산에 대한 정족수. 쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야 한다.
- R = 읽기 연산에 대한 정족수. 읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답을 받아야 한다.
```

W, R, N의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점을 찾는 전형적인 과정이다.

```
- R=1 & W=N: 빠른 읽기 연산에 최적화된 시스템
- W=1 & R=N: 빠른 쓰기 연산에 최적화된 시스템
- W+R > N: 강한 일관성이 보장됨 (보통 N=3 & W=R=2)
- W+R <= N: 강한 일관성이 보장되지 않음
```

#### 일관성 모델 (consistency model)

일관성 모델은 데이터 일관성의 수준을 결정한다.

|종류|의미|
|---|---|
|강한(strong) 일관성|모든 읽기 연산은 가장 최근에 갱신된 결과를 반환한다.|
|약한(week) 일관성|읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.|
|결과적(eventual) 일관성|약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영(동기화)되는 모델이다.|

- `강한 일관성` 은 모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 해당 데이터에 대한 읽기/쓰기를 금지해 달성할 수 있다. <br>
  → 가용성이 떨어진다. 따라서 다이나모 또는 카산드라 저장소는 고가용성을 위해 결과적 일관성 모델을 선택했다.
- `결과적 일관성` 을 따를 경우 쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨어질 수 있다. <br>
  → 클라이언트가 해결해야 한다.

> [!Note]
> **비 일관성 해소 기법: 벡터 시계 (vector clock)**
>
> `버저닝(versioning)` 을 통해 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만든다. <br>
> 그리고 버전의 충돌을 판별하기 위해 벡터 시계를 사용한다.
>
> - `[서버, 버전]`의 순서쌍을 데이터에 매단다. (ex. D([S1, v1], [S2, v2], ...)
> - [Si, vi]가 있으면 vi를 증가시킨다.
> - 그렇지 않으면 새 항목 [Si, 1]을 만든다.
>
> 이 때 다른 버전에 포함된 모든 구성요소의 값이 해당 버전에 포함된 모든 구성요소 값보다 같거나 크면 충돌이 없다.

<br>

### 장애 감지 (failure detection)

분산 시스템에서는 보통 두 대 이상의 서버가 똑같이 특정 서버의 장애를 보고해야 해당 서버에 실제로 장애가 발생했다고 간주한다.

#### 멀티캐스팅 (multicasting)

모든 노드 사이에 멀티캐스팅 채널을 구축한다. <br>
장애를 감지하는 가장 쉬운 방법이지만 서버가 많을 수록 비효율적이다.

#### 가십 프로토콜 (gossip protocol)

- 각 노드는 `멤버십 목록(membership list)` 를 유지한다. 멤버십 목록은 각 멤버 ID와 그 `박동 카운터(heartbeat counter)` 쌍의 목록이다.
- 각 노드는 주기적으로 자신의 박동 카운터를 증가시킨다.
- 각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보낸다.
- 박동 카운터 목록을 받은 노드는 멤버십 목록을 최신 값으로 갱신한다.
- 어떤 멤버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애 상태인 것으로 간주한다.

<br>

### 장애 처리

#### 일시적 장애 처리

- 엄격한 정족수(strict quorum) 접근법: 데이터 일관성을 지키기 위해 읽기와 쓰기 연산을 금지한다.

- 느슨한 정족수(sloppy quorum) 접근법: 가용성을 우선한다.
  - 쓰기 연산을 수행할 W개의 건강한 서버 & 읽기 연산을 수행할 R개의 건강한 서버를 해시 링에서 고른다.
  - 장애 상태의 서버로 가는 요청은 다른 서버가 처리한다.
  - 대신 처리된 변경사항은 해당 서버가 복구되었을 때 일괄 반영하여 데이터 일관성을 보존한다. <br>
    : 임시로 쓰기 연산을 수행한 서버에 단서(hint)를 남긴다. → `단서 후 임시 위탁(hinted handoff)` 기법

#### 영구적 장애 처리

- 반-엔트로피(anti-entropy) 프로토콜: 사본들을 동기화해 최신 버전으로 갱신한다. 
  - `머클(Merkle) 트리` 를 사용해 전송 데이터의 양을 줄인다.
  - 머클 트리를 사용하면 동기화해야 할 데이터의 양은 실제로 존재하는 차이의 크기에만 비례한다.

#### 데이터 센터 장애 처리

데이터 센터 장애에 대응하기 위해서는 데이터를 여러 데이터 센터에 `다중화` 하는 것이 중요하다.
